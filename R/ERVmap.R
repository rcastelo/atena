#' Build an ERVmap parameter object
#'
#' Build an object of the class \code{ERVmapParam}
#'
#' @param bfl A \code{BamFile} or \code{BamFileList} object, or a character
#' string vector of BAM filenames.
#'
#' @param teFeatures A \code{GRanges} or \code{GRangesList} object with the
#' transposable element (TE) annotated features to be quantified. Elements in 
#' this object should have names, which will be used as a grouping factor for 
#' genomic ranges forming a common locus, unless other metadata column names are 
#' specified in the \code{aggregateby} parameter.
#'
#' @param aggregateby Character vector with column names in the annotation
#' to be used to aggregate quantifications. By default, this is an empty vector,
#' which means that the names of the input \code{GRanges} or \code{GRangesList}
#' object given in the \code{teFeatures} parameter will be used to aggregate
#' quantifications.
#'
#' @param geneFeatures A \code{GRanges} or \code{GRangesList} object with the
#' gene annotated features to be quantified. Only unique counts are used for
#' quantifying gene features given in this parameter.
#'
#' @param singleEnd (Default TRUE) Logical value indicating if reads are single
#' (\code{TRUE}) or paired-end (\code{FALSE}).
#'
#' @param strandMode (Default 1) Numeric vector which can take values 0, 1 or 2.
#'   The strand mode is a per-object switch on
#'   \code{\link[GenomicAlignments:GAlignmentPairs-class]{GAlignmentPairs}}
#'   objects that controls the behavior of the strand getter. See
#'   \code{\link[GenomicAlignments:GAlignmentPairs-class]{GAlignmentPairs}}
#'   class for further detail. If \code{singleEnd = TRUE}, then \code{strandMode}
#'   is ignored.
#'
#' @param ignoreStrand (Default TRUE) A logical which defines if the strand
#' should be taken into consideration when computing the overlap between reads
#' and TEs in the annotations. When \code{ignore_strand = FALSE}, only those
#' reads which overlap the TE and are on the same strand are counted. On the 
#' contrary, when \code{ignore_strand = TRUE}, any read overlapping an element 
#' in \code{teFeatures} is counted regardless of the strand.
#'
#' @param fragments (Default not \code{singleEnd}) A logical; applied to
#' paired-end data only. When \code{fragments=TRUE} (default), the read-counting
#' method in the original ERVmap algorithm will be applied: each mate of a
#' paired-end read is counted once and, therefore, two mates mapping to the
#' same element result in adding up a count value of two. When
#' \code{fragments=FALSE}, if the two mates of a paired-end read map to the same
#' element, they are counted as a single hit and singletons, reads with unmapped
#' pairs and other fragments, are not counted.
#'
#' @param maxMismatchRate (Default 0.02) Numeric value storing the maximum mismatch
#' rate employed by the ERVmap algorithm to discard aligned reads whose rate of
#' of sum of hard and soft clipping, or of the edit distance over the genome
#' reference, to the length of the read is above this threshold.
#'
#' @param filterUniqReads (Default TRUE) Logical value indicating whether to apply
#' the filters of the ERVmap algorithm to unique reads (TRUE) or not (FALSE). 
#' These filters, which are always applied to multi-mapping reads, can be 
#' optional for unique reads. If \code{filterUniqReads = TRUE} (equivalent to 
#' the original approach proposed by ERVmap authors), the unique reads not 
#' passing one or more filters from the ERVmap algorithm are discarded to 
#' compute TE expression. When \code{filterUniqReads = FALSE} secondary 
#' alignments need to the present in the input BAM file in order to
#' differentiate unique from multi-mapping reads.
#'
#' @param suboptimalAlignmentTag (Default "auto") Character string storing the
#' tag name in the BAM files that stores the suboptimal alignment score used in
#' the third filter of ERVmap; see Tokuyama et al. (2018). The default,
#' \code{suboptimalAlignmentTag="auto"}, assumes that either the BAM files were
#' generated by BWA and include a tag called \code{XS} that stores the suboptimal
#' alignment score or, if the \code{XS} tag is not available, then it uses
#' the available secondary alignments to implement an analogous approach to that
#' of the third ERVmap filter. When \code{suboptimalAlignmentTag="none"}, it also 
#' performs the latter approach even when the tag \code{XS} is available. When
#' this parameter is different from \code{"auto"} and \code{"none"}, a tag
#' with the given name is used to extract the suboptimal alignment score.
#' The absence of that tag will prompt an error.
#'
#' @param suboptimalAlignmentCutoff (Default 5) Numeric value storing the cutoff
#' above which the difference between the alignment score and the suboptimal
#' alignment score is considered sufficiently large to retain the alignment. When
#' this value is set to \code{NA}, then the filtering step based on suboptimal
#' alignment scores is skipped.
#' 
#' @param geneCountMode (Default "all") Character string indicating if the ERVmap
#' read filters applied to quantify TEs expression should also be applied when
#' quantifying gene expression ("ervmap") or not ("all"), in which case all 
#' primary alignments mapping to genes are counted.
#'
#' @details
#' This is the constructor function for objects of the class
#' \code{ERVmapParam-class}. This type of object is the input to the
#' function \code{\link{qtex}()} for quantifying expression of transposable
#' elements using the ERVmap method
#' \href{https://doi.org/10.1073/pnas.1814589115}{Tokuyama et al. (2018)}. The
#' ERVmap algorithm processes reads following conservative filtering criteria
#' to provide reliable raw count data for each TE.
#' 
#' @return A \linkS4class{ERVmapParam} object.
#'
#' @examples
#' bamfiles <- list.files(system.file("extdata", package="atena"),
#'                        pattern="*.bam", full.names=TRUE)
#' annot <- ERVmap_ann()
#' empar <- ERVmapParam(bamfiles, annot, singleEnd = TRUE)
#' empar
#'
#' @references
#' Tokuyama M et al. ERVmap analysis reveals genome-wide transcription of human
#' endogenous retroviruses. PNAS. 2018;115(50):12565-12572. DOI:
#' \url{https://doi.org/10.1073/pnas.1814589115}
#'
#' @importFrom methods is new
#' @export
ERVmapParam <- function(bfl, teFeatures, aggregateby=character(0),
                        geneFeatures=NA,
                        singleEnd=TRUE,
                        ignoreStrand=TRUE,
                        strandMode=1L,
                        fragments=!singleEnd,
                        filterUniqReads=FALSE,
                        maxMismatchRate=0.02,
                        suboptimalAlignmentTag="auto",
                        suboptimalAlignmentCutoff=5,
                        geneCountMode="all") {

  bfl <- .checkBamFileListArgs(bfl, singleEnd, fragments)

  readmapper <- .checkBamReadMapper(path(bfl))

  features <- .processFeatures(teFeatures, deparse(substitute(teFeatures)),
                               geneFeatures, deparse(substitute(geneFeatures)),
                               aggregateby)
  
  new("ERVmapParam", bfl=bfl, features=features, aggregateby=aggregateby,
      singleEnd=singleEnd, ignoreStrand=ignoreStrand,
      strandMode=as.integer(strandMode), fragments=fragments,
      filterUniqReads=filterUniqReads, maxMismatchRate=maxMismatchRate,
      readMapper=readmapper, suboptimalAlignmentTag=suboptimalAlignmentTag,
      suboptimalAlignmentCutoff=as.numeric(suboptimalAlignmentCutoff),
      geneCountMode=geneCountMode)
}

#' @param object A \linkS4class{ERVmapParam} object.
#'
#' @importFrom GenomeInfoDb seqlevels
#' @export
#' @aliases show,ERVmapParam-method
#' @rdname ERVmapParam-class
setMethod("show", "ERVmapParam",
          function(object) {
            cat(class(object), "object\n")
            cat(sprintf("# BAM files (%d): %s\n", length(object@bfl),
                        .pprintnames(names(object@bfl))))
            cat(sprintf("# features (%d): %s\n", length(object@features),
                        ifelse(is.null(names(object@features)),
                               paste("on", .pprintnames(seqlevels(object@features))),
                               .pprintnames(names(object@features)))))
            cat(sprintf("# %s, %s",
                        ifelse(object@singleEnd, "single-end", "paired-end"),
                        ifelse(object@ignoreStrand, "unstranded", "stranded")))
            if (!object@ignoreStrand)
              cat(sprintf(" (strandMode=%d)", object@strandMode))
            cat(sprintf(", %s",
                        ifelse(object@filterUniqReads, "unique-read filtering",
                               "unfiltered unique reads")))
            if (!object@singleEnd)
              cat(sprintf(", %s",
                          ifelse(object@fragments, "counting each paired-end mate",
                                 "counting both paired-end mates")))
            cat("\n")
          })

#' @importFrom BiocParallel SerialParam bplapply
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @export
#' @aliases qtex
#' @aliases qtex,ERVmapParam-method
#' @rdname qtex
setMethod("qtex", "ERVmapParam",
          function(x, phenodata=NULL, mode=ovUnion, yieldSize=1e6L, verbose=1,
                   BPPARAM=SerialParam(progressbar=ifelse(verbose==1, TRUE, FALSE))) {
            .checkPhenodata(phenodata, length(x@bfl))

            cnt <- bplapply(x@bfl, .qtex_ervmap, empar=x, mode=mode,
                            yieldSize=yieldSize, verbose=verbose, BPPARAM=BPPARAM)
            cnt <- do.call("cbind", cnt)
            colData <- .createColumnData(cnt, phenodata)
            colnames(cnt) <- rownames(colData)

            features <- .consolidateFeatures(x, rownames(cnt))

            SummarizedExperiment(assays=list(counts=cnt),
                                 rowRanges=features,
                                 colData=colData)
          })



#' @importFrom BiocGenerics basename path
#' @importFrom Rsamtools ScanBamParam yieldSize yieldSize<-
#' @importFrom methods formalArgs
#' @importFrom IRanges findOverlapPairs
#' @importFrom GenomicRanges pintersect
.qtex_ervmap <- function(bf, empar, mode, yieldSize=1000000, verbose) {
  
  iste <- as.vector(empar@features$isTE)

  mode=match.fun(mode)
  readfun <- .getReadFunction(empar@singleEnd, empar@fragments)

  ## suboptimalAlignmentTag set to 'auto' implies following the original
  ## ERVmap algorithm; when the read mapper is BWA, it is assumed that
  ## the tag 'XS' stores the suboptimal alignment score.
  soatag <- .getsoatag(empar@suboptimalAlignmentTag, empar@readMapper)
  avtags <- .getavtags(empar, bf, soatag)
  avgene <- !is.null(iste)
  sbflags <- .setBamFlags(bf, empar, avtags, avgene)
  
  ## are suboptimal alignment scores available?
  avsoas <- .soasAvail(empar@suboptimalAlignmentCutoff, soatag, avtags, 
                       bf, verbose)
  if ((!is.na(empar@suboptimalAlignmentCutoff)) & isTRUE(soatag %in% avtags)) {
    empar@suboptimalAlignmentTag <- soatag
  }
  
  param <- ScanBamParam(flag=sbflags, what="flag", tag=avtags)

  ## 'ov' is a 'Hits' object with the overlaps between aligned reads and features
  ov <- Hits(nLnode=0, nRnode=length(empar@features), sort.by.query=TRUE)
  ## 'ovdiscard' is a 'Hits' object with the overlaps between aligned discarted reads and features
  ovdiscard <- Hits(nLnode=0, nRnode=length(empar@features[!iste]), sort.by.query=TRUE)

  ## 'salnmask' is logical mask flagging whether an alignment is secondary
  salnmask <- logical(0)
  salnbestAS <- integer(0)
  ## 'alnAS' stores the alignment score
  alnAS <- integer(0)
  ## 'alnNH' stores the NH tag
  alnNH <- integer(0)
  ## 'readids' stores the unique read identifiers, while 'alnreadidx' stores for each
  ## aligned read the index of the corresponding unique read identifier
  readids <- character(0) # stores read identifiers (both filtered (pass the filter) and discarded) only once
  alnreadidx <- integer(0) # stores for each read that pass the filter, the index of the corresponding unique read identifier in readids
  readidx <- integer(0) # stores for each read (both filtered and discarded reads), the index of the corresponding unique read identifier in readids
  thisalnAS <- integer(0)
  alnreadids <- character(0)
  n <- nprimary <- nfiltered <- 0
  
  strand_arg <- "strandMode" %in% formalArgs(readfun)
  yieldSize(bf) <- yieldSize
  open(bf)
  while (length(alnreads <- do.call(readfun, c(list(file = bf), 
                                               list(param=param), 
                                               list(strandMode=empar@strandMode)[strand_arg], 
                                               list(use.names=(!avsoas || avgene)))))) {
    n <- n + length(alnreads)
    aqw <- .getAlignmentQueryWidth(alnreads)  ## get alignment query width
    anm <- .getAlignmentMismatches(alnreads)  ## get alignment mismatches
    asc <- .getAlignmentSumClipping(alnreads) ## get sum of soft & hard alignment clippings
    ## Tokuyama et al. (2018) pg. 12571. reads/fragments are kept
    ## if: (1) the ratio of sum of hard and soft clipping to the
    ## sequence read length is < 0.02; (2) the ratio of the edit
    ## distance to the sequence read length is < 0.02
    mask <- ((asc / aqw) < empar@maxMismatchRate) & ((anm / aqw) < empar@maxMismatchRate)
    
    ## fetch secondary alignment mask
    thissalnmask <- .secondaryAlignmentMask(alnreads)
    
    if (!is.na(empar@suboptimalAlignmentCutoff)) {
      thisalnAS <- .getAlignmentTagScore(alnreads, tag="AS")
      if (avsoas) {
        sas <- .getAlignmentTagScore(alnreads, tag=empar@suboptimalAlignmentTag)
        ## (3) the difference between the alignment score from BWA (AS)
        ## and the suboptimal alignment score from BWA (field XS) >= 5,
        mask <- mask & (thisalnAS - sas >= empar@suboptimalAlignmentCutoff) 
      } else if (!any(thissalnmask)) {
        stop("The BAM file does not contain secondary alignments nor suboptimal alignment scores. Either set suboptimalAlignmentCutoff = NA or provide a BAM file with secondary alignments or suboptimal alignment scores.")
      }
    }
    
    if (avgene || (!is.na(empar@suboptimalAlignmentCutoff) & !avsoas)) {
      alnreadids <- .getAlnreadids(alnreads, empar@fragments)
    }
    
    mask[thissalnmask] <- TRUE # Setting TRUE in mask to secondary alignments

    ## filter out alignments not passing the previous filter
    if (empar@fragments) {
      alnreadsdiscard <- unlist(alnreads)[!mask & !thissalnmask] 
    } else {
      alnreadsdiscard <- alnreads[!mask & !thissalnmask]
    }
    alnreads <- .filteralnreads(empar, alnreads, mask, thissalnmask, avsoas, avgene)
    
    ## Reading NH tag if secondary alignments are not available
    if (!any(thissalnmask) & avgene) {
      if (isTRUE("NH" %in% avtags)) {
        thisNH <- .getAlignmentTagScore(alnreads, tag="NH")
        alnNH <- c(alnNH,thisNH)
      } else {
        warning("secondary alignments and NH tag not available in BAM file. Unique reads cannot be differentiated from multi-mapping reads. All reads aligned to overlapping regions between genes and TEs will be considered as gene counts.")
      }
    }

    ## calculate and store overlaps between the filtered reads and features
    thisov <- mode(alnreads, empar@features, ignoreStrand=empar@ignoreStrand)
    ov <- .appendHits(ov, thisov)
    
    if (avgene && empar@geneCountMode == "all") {
      ## calculate and store overlaps between the discarded reads and genes
      thisovdiscard <- mode(alnreadsdiscard, empar@features[!iste], 
                           ignoreStrand=empar@ignoreStrand)
      ovdiscard <- .appendHits(ovdiscard, thisovdiscard)
    }

    ## if suboptimal alignment scores are not available and the
    ## corresponding cutoff value is not NA
    if (!avsoas && !is.na(empar@suboptimalAlignmentCutoff)) {
      
      ## store best secondary alignment score
      salnbestAS <- .findSuboptAlignScore(thisalnAS, thissalnmask, alnreadids, 
                                          salnbestAS)

      ## filter now alignment scores and read identifiers
      thisalnAS <- thisalnAS[mask]
      
      ## store and alignment score
      alnAS <- c(alnAS, thisalnAS)
    }
    
    ## store secondary alignment mask 
    salnmask <- c(salnmask, thissalnmask[mask])
    
    ## filter now read identifiers
    if (avgene || (!is.na(empar@suboptimalAlignmentCutoff) & !avsoas)) {

      ## store unique read identifiers and what alignment comes from what read
      ## First multiple alignments from the same read in the same chunk are identified
      alnreadids_uniq <- unique(alnreadids)
      mt <- match(alnreadids, alnreadids_uniq) 
      l <- length(alnreadids_uniq)
      alnreadids_uniq <- c(alnreadids_uniq, alnreadids_uniq[is.na(mt)])
      mt[is.na(mt)] <- (l+1):(l+sum(is.na(mt)))
      chunkidx <- mt
      # Second, the index vectors are created
      mt <- match(alnreadids_uniq, readids) 
      l <- length(readids)
      readids <- c(readids, alnreadids_uniq[is.na(mt)]) # readids contains just once every readID of all reads in the BAM file
      mt[is.na(mt)] <- (l+1):(l+sum(is.na(mt)))
      readidx <- c(readidx, mt[chunkidx]) # index for all alignments in the BAM file
      alnreadidx <- c(alnreadidx, mt[chunkidx][mask]) # index for all alignments with mask == TRUE.

    }
    
    if (verbose > 1) {
      nfiltered <- nfiltered + sum(mask & !thissalnmask)
      cat(sprintf("%s: %d alignments processed (%d are primary and pass filters).\n",
                  basename(path(bf)), n, nfiltered))
    }
  }
  close(bf)
  
  
  ## if suboptimal alignment scores are available or they are not but
  ## we do not have secondary alignments either, then simply count filtered
  ## reads. in the latter case, we issue a warning.
  if (avsoas || !any(salnmask) || is.na(empar@suboptimalAlignmentCutoff)) {
    
    if (avgene) {
      cntvec <- .countbymatrix(empar, ov, alnreadidx, salnmask, alnAS, salnbestAS, 
                               avgene, applysoasfilter = FALSE, readidx, mask, alnNH)
    } else {
      cntvec <- countSubjectHits(ov)
    }
      
    if (!is.na(empar@suboptimalAlignmentCutoff) && !avsoas)
      warning("suboptimal alignment scores and secondary alignments not available: skipping suboptimal alignment filtering.")
  } else {
    ## if suboptimal alignment scores are not available we can attempt to do
    ## the suboptimal alignment filtering using the secondary alignments
    salnbestAS <- salnbestAS[match(readids[alnreadidx], names(salnbestAS))]
    salnbestAS[is.na(salnbestAS)] <- -99L
    rm(readids)
    gc()
    cntvec <- .countbymatrix(empar, ov, alnreadidx, salnmask, alnAS, salnbestAS, 
                             avgene, applysoasfilter = TRUE, readidx, mask, alnNH)

    if (verbose > 1)
      cat(sprintf("%s: %d alignments processed (%d are primary and pass subptimal alignment filtering).\n",
                  basename(path(bf)), n, sum(cntvec)))
  }
  
  names(cntvec) <- names(empar@features)

  if (isTRUE(avgene) && empar@geneCountMode == "all") {
    ## Adding counts of reads not passing ERVmap filters to genes 
    cntvec[!iste] <- cntvec[!iste] + countSubjectHits(ovdiscard)
  }
    
  ## aggregate quantifications if necessary
  if (length(empar@aggregateby) > 0) {
    if (avgene) {
      f <- .factoraggregateby(empar@features[iste,], empar@aggregateby)
      f <- c(f, names(empar@features)[!iste])
    } else {
      f <- .factoraggregateby(empar@features, empar@aggregateby)
    }
    
    stopifnot(length(f) == length(cntvec)) ## QC
    cntvec <- tapply(cntvec, f, sum, na.rm=TRUE)
  }

  cntvec
}




## Function to know which tags are present in the BAM file (single-end).
## Input is a BamFile object. Returns a data.frame with tags as columns and the 
## BAM file as row, indicating if each tag is present in the BAM file (TRUE) or 
## not (FALSE).

#' @importFrom Rsamtools scanBamFlag ScanBamParam yieldSize yieldSize<-
#' @importFrom S4Vectors mcols
.get_tags_in_BAM_singleend <- function(bf, soatag="XS") {
  
  yieldSize(bf) <- 1000
  sbflags <- scanBamFlag(isUnmappedQuery = FALSE,
                         isDuplicate = FALSE,
                         isNotPassingQualityControls = FALSE,
                         isSupplementaryAlignment = FALSE,
                         ## XS is only set by BWA for primary alignments
                         isSecondaryAlignment=FALSE)
  
  param <- ScanBamParam(flag = sbflags,
                        tag = c("nM", "NM", "AS", "NH", soatag))
  
  tags <- param@tag
  tags_df <- data.frame(matrix(nrow = length(bf), ncol = length(tags)))
  colnames(tags_df) <- tags
  
  open(bf)
  r_test <- readGAlignments(bf, param = param)
  close(bf)
  
  # Testing, for each sample, if the files contain the different tags
  tags_df[, "NH"] <- ifelse(all(is.na(mcols(r_test)$NH)), FALSE, TRUE)
  tags_df[, "NM"] <- ifelse(all(is.na(mcols(r_test)$NM)), FALSE, TRUE)
  tags_df[, "nM"] <- ifelse(all(is.na(mcols(r_test)$nM)), FALSE, TRUE)
  tags_df[, "AS"] <- ifelse(all(is.na(mcols(r_test)$AS)), FALSE, TRUE)
  if (!is.null(soatag))
    tags_df[, soatag] <- ifelse(all(grepl("\\d", (mcols(r_test)[[soatag]]))), TRUE, FALSE)
  
  return(tags_df)
}



## Function to know which tags are present in the BAM file (paired-end).
## Input is a BamFile object. Returns a data.frame with tags as columns and the 
## BAM file as row, indicating if each tag is present in the BAM file (TRUE) or 
## not (FALSE).

#' @importFrom Rsamtools scanBamFlag ScanBamParam yieldSize yieldSize<- asMates asMates<-
#' @importFrom S4Vectors mcols
.get_tags_in_BAM_pairedend <- function(bf, empar, soatag="XS") {
  yieldSize(bf) <- 1000
  asMates(bf) <- TRUE
  sbflags <- scanBamFlag(isUnmappedQuery = FALSE,
                         isProperPair = TRUE,
                         isDuplicate = FALSE,
                         isNotPassingQualityControls = FALSE,
                         isSupplementaryAlignment = FALSE,
                         ## XS is only set by BWA for primary alignments
                         isSecondaryAlignment=FALSE)
  
  param <- ScanBamParam(flag = sbflags,
                        tag = c("nM", "NM", "AS", "NH", soatag))
  
  tags <- param@tag
  tags_df <- data.frame(matrix(nrow = length(bf), ncol = length(tags)))
  colnames(tags_df) <- tags
  
  open(bf)
  r_test <- readGAlignmentPairs(bf, param = param, strandMode = empar@strandMode)
  close(bf)
  
  # Testing, for each sample, if the files contain the different tags
  tags_df[, "NH"] <- ifelse(all(is.na(mcols(first(r_test))$NH)), FALSE, TRUE)
  tags_df[, "NM"] <- ifelse(all(is.na(mcols(first(r_test))$NM)), FALSE, TRUE)
  tags_df[, "nM"] <- ifelse(all(is.na(mcols(first(r_test))$nM)), FALSE, TRUE)
  tags_df[, "AS"] <- ifelse(all(is.na(mcols(first(r_test))$AS)), FALSE, TRUE)
  if (!is.null(soatag))
    tags_df[, soatag] <- ifelse(all(grepl("\\d", (mcols(first(r_test))[[soatag]]))), TRUE, FALSE)
  
  return(tags_df)
}




#' @importFrom Rsamtools scanBamFlag
.setBamFlags <- function(bf, empar, avtags, avgene) {
  sbflags <- scanBamFlag()
  
  ## if we use the 'XS' tag then do not read secondary alignments
  if ("XS" %in% avtags && empar@readMapper == "bwa" &&
      empar@suboptimalAlignmentTag %in% c("auto", "XS") && !avgene)
    sbflags <- scanBamFlag(isUnmappedQuery=FALSE,
                           isDuplicate=FALSE,
                           isNotPassingQualityControls=FALSE,
                           isSupplementaryAlignment=FALSE,
                           isSecondaryAlignment=FALSE)
  else ## otherwise do not exclude secondary alignments
    sbflags <- scanBamFlag(isUnmappedQuery=FALSE,
                           isDuplicate=FALSE,
                           isNotPassingQualityControls=FALSE,
                           isSupplementaryAlignment=FALSE)
  
  sbflags
}




#' @importFrom S4Vectors queryHits subjectHits
#' @importFrom Matrix rowSums
#' @importFrom sparseMatrixStats rowMaxs
.suboptimalAlignmentFilteringCounts <- function(empar, ov, alnreadidx, alnAS, salnmask, salnbestAS) {
  ## suboptimal alignment filtering using the available secondary
  ## alignments. according to Tokuyama et al. (2018) pg. 12571.,
  ## reads/fragments are kept if the difference between the alignment
  ## score from BWA (AS) and the suboptimal alignment score from BWA
  ## (field XS) >= 5. here we calculate the suboptimal alignment score
  ## by searching for the secondary alignment with the highest score.

  ## fetch all different read identifiers from the overlapping alignments
  rd_idx <- sort(unique(alnreadidx[queryHits(ov)]))

  ## fetch all different transcripts from the overlapping alignments
  tx_idx <- sort(unique(subjectHits(ov)))

  ## build matrices with primary alignment flags, alignment scores (AS) 
  ## and best secondary alignment AS
  palnmat <- .buildOvValuesMatrix(ov, !salnmask, alnreadidx, rd_idx, tx_idx)
  asmat <- .buildOvValuesMatrix(ov, alnAS, alnreadidx, rd_idx, tx_idx)
  salnbestasmat <- .buildOvValuesMatrix(ov, salnbestAS, alnreadidx, rd_idx, tx_idx)

  ## AS from primary alignments
  asprimaryaln <- rowMaxs(palnmat * asmat)
  ## fetch maximum AS from secondary alignments
  salnmaxas <- rowMaxs(salnbestasmat)
  salnmaxas[salnmaxas == 0] <- -99
  mask <- ((asprimaryaln - salnmaxas) >= empar@suboptimalAlignmentCutoff)
  
  palnmat <- palnmat[mask, ]
  cntvec <- rep(0, length(empar@features))
  cntvec[tx_idx] <- colSums(palnmat)
  
  cntvec
}

#' @importFrom S4Vectors mcols first second
#' @importFrom Rsamtools bamFlagTest
.secondaryAlignmentMask <- function(aln) {
  mask <- NULL
  if (is(aln, "GAlignments"))
    mask <- bamFlagTest(mcols(aln)$flag, "isSecondaryAlignment")
  else if (is(aln, "GAlignmentPairs")) {
    mask <- bamFlagTest(mcols(first(aln))$flag, "isSecondaryAlignment") |
            bamFlagTest(mcols(second(aln))$flag, "isSecondaryAlignment")
  } else if (is(aln, "GAlignmentsList")) {
    mask <- bamFlagTest(mcols(unlist(aln, use.names=FALSE))$flag,
                        "isSecondaryAlignment")
  } else
    stop(sprintf(".secondaryAlignmentMask: wrong class %s\n", class(aln)))

  mask
}

#' @importFrom S4Vectors mcols first second
.getAlignmentTagScore <- function(aln, tag, pairedsummaryfun=pmin.int) {
  if (is(aln, "GAlignments"))
    score <- as.integer(mcols(aln)[[tag]])
  else if (is(aln, "GAlignmentPairs")) {
    ## take the minimum score from both mates
    score <- pairedsummaryfun(as.integer(mcols(first(aln))[[tag]]), mcols(second(aln))[[tag]])
  } else if (is(aln, "GAlignmentsList")) {
    score <- as.integer(mcols(unlist(aln, use.names=FALSE))[[tag]])
  } else
    stop(sprintf(".getAlignmentTagScore: wrong class %s\n", class(aln)))

  as.integer(score)
}


#' @importFrom S4Vectors mcols
.fetchNMtag <- function(aln) {
  nmtag <- "NM"
  if (is(aln, "GAlignments")) {
    if (is.null(mcols(aln)[[nmtag]]) || all(is.na(mcols(aln)[[nmtag]]))) {
      nmtag <- "nM"
      if (is.null(mcols(aln)[[nmtag]]) || all(is.na(mcols(aln)[[nmtag]])))
        stop("no NM or nM tag in BAM file.")
    }
  } else if (is(aln, "GAlignmentPairs")) {
    if (is.null(mcols(first(aln))[[nmtag]]) || all(is.na(mcols(first(aln))[[nmtag]]))) {
      nmtag <- "nM"
      if (is.null(mcols(first(aln))[[nmtag]]) || all(is.na(mcols(first(aln))[[nmtag]])))
        stop("no NM or nM tag in BAM file.")
    }
  } else if (is(aln, "GAlignmentsList")) {
    if (is.null(mcols(unlist(aln))[[nmtag]]) || all(is.na(mcols(unlist(aln))[[nmtag]]))) {
      nmtag <- "nM"
      if (is.null(mcols(unlist(aln))[[nmtag]]) || all(is.na(mcols(unlist(aln))[[nmtag]])))
        stop("no NM or nM tag in BAM file.")
    }
  } else
    stop(sprintf(".getAlignmentMismatches: wrong class %s\n", class(aln)))

  nmtag
}

#' @importFrom S4Vectors mcols first second
#' @importFrom IRanges relist
.getAlignmentMismatches <- function(aln) {
  mm <- NULL
  nmtag <- .fetchNMtag(aln)

  if (is(aln, "GAlignments"))
    mm <- mcols(aln)[[nmtag]]
  else if (is(aln, "GAlignmentPairs")) {
    ## take the celing of the mean of mismatches from both mates
    mm1 <- as.integer(mcols(first(aln))[[nmtag]])
    mm2 <- as.integer(mcols(second(aln))[[nmtag]])
    mm1[is.na(mm1)] <- mm2[is.na(mm1)]
    mm2[is.na(mm2)] <- mm1[is.na(mm2)]
    mm <- ceiling((mm1 + mm2) / 2)
  } else if (is(aln, "GAlignmentsList")) {
    mm <- mcols(unlist(aln, use.names=FALSE))[[nmtag]]
  } else
    stop(sprintf(".getAlignmentMismatches: wrong class %s\n", class(aln)))

  as.integer(mm)
}

#' @importFrom S4Vectors mcols first second
#' @importFrom IRanges relist
#' @importFrom GenomicAlignments qwidth
.getAlignmentQueryWidth <- function(aln) {
  qw <- NULL
  if (is(aln, "GAlignments"))
    qw <- qwidth(aln)
  else if (is(aln, "GAlignmentPairs")) {
    ## take the ceiling of the mean of query widths from both mates
    qw1 <- qwidth(first(aln))
    qw2 <- qwidth(second(aln))
    qw1[is.na(qw1)] <- qw2[is.na(qw1)]
    qw2[is.na(qw2)] <- qw1[is.na(qw2)]
    qw <- ceiling((qw1 + qw2) / 2)
  } else if (is(aln, "GAlignmentsList")) {
    qw <- qwidth(unlist(aln, use.names=FALSE))
  } else
    stop(sprintf(".getAlignmentQueryWidth: wrong class %s\n", class(aln)))

  as.integer(qw)
}

#' @importFrom S4Vectors mcols first second List
#' @importFrom GenomicAlignments cigar explodeCigarOpLengths
.getAlignmentSumClipping <- function(aln) {
  sc <- NULL
  if (is(aln, "GAlignments"))
    sc <- sapply(explodeCigarOpLengths(cigar(aln), ops=c("H", "S")), sum)
  else if (is(aln, "GAlignmentPairs")) {
    ## take the ceiling of the mean of query widths from both mates
    sc1 <- sapply(explodeCigarOpLengths(cigar(first(aln)), ops=c("H", "S")), sum)
    sc2 <- sapply(explodeCigarOpLengths(cigar(second(aln)), ops=c("H", "S")), sum)
    sc1[is.na(sc1)] <- sc2[is.na(sc1)]
    sc2[is.na(sc2)] <- sc1[is.na(sc2)]
    sc <- ceiling((sc1 + sc2) / 2)
  } else if (is(aln, "GAlignmentsList")) {
    sc <- sapply(explodeCigarOpLengths(cigar(unlist(aln, use.names=FALSE)),
                                       ops=c("H", "S")),
                 sum)
  } else
    stop(sprintf(".getAlignmentSumClipping: wrong class %s\n", class(aln)))

  as.integer(sc)
}

#' @importFrom S4Vectors queryHits subjectHits
#' @importFrom Matrix Matrix
.buildOvValuesMatrix <- function(ov, values, aridx, ridx, fidx) {
  stopifnot(class(values) %in% c("logical", "integer")) ## QC
  ovmat <- Matrix(do.call(class(values), list(1)),
                  nrow=length(ridx), ncol=length(fidx))
  mt1 <- match(aridx[queryHits(ov)], ridx)
  mt2 <- match(subjectHits(ov), fidx)
  ovmat[cbind(mt1, mt2)] <- values[queryHits(ov)]

  ovmat
}

## Obtains the name of the tag containing the suboptimal alignment score, if
## present
.getsoatag <- function(suboptimalAlignmentTag, readMapper) {
  soatag <- NULL
  if (suboptimalAlignmentTag == "auto" && readMapper == "bwa") {
    soatag <- "XS"
  } else if (nchar(suboptimalAlignmentTag) == 2) {
    soatag <- suboptimalAlignmentTag
  }
  soatag
}

## Calls internal functions to obtain the name of the available tags depending
## on whether the data is single- or paired-end
#' @importFrom BiocGenerics basename path
.getavtags <- function(empar, bf, soatag) {
  avtags <- character(0)
  if (empar@singleEnd)
    avtags <- .get_tags_in_BAM_singleend(bf, soatag=soatag)
  else
    avtags <- .get_tags_in_BAM_pairedend(bf, empar=empar, soatag=soatag)
  
  avtags <- colnames(avtags)[unlist(avtags)]
  if (!empar@suboptimalAlignmentTag %in% c("auto", "none", avtags))
    stop(sprintf("suboptimal alignment tag '%s' not available in BAM file %s.",
                 empar@suboptimalAlignmentTag, basename(path(bf))))
  avtags
}


## Looks if the suboptimal alignment score tag reported by the user is present
## in the BAM file.
#' @importFrom BiocGenerics basename path
.soasAvail <- function(suboptimalAlignmentCutoff, soatag, avtags, bf, verbose) {
  avsoas <- FALSE 
  if (!is.na(suboptimalAlignmentCutoff)) {
    if (isTRUE(soatag %in% avtags)) {
      avsoas <- TRUE
      if (verbose > 1)
        cat(sprintf("%s: using suboptimal alignment scores from tag '%s'.\n",
                    basename(path(bf)), soatag))
    } else if (verbose > 1)
      cat(sprintf("%s: suboptimal alignment filtering based on secondary alignments.\n",
                  basename(path(bf))))
  } else if (verbose > 1)
    cat("suboptimal alignment cutoff value is 'NA', skipping suboptimal alignment filtering.\n")
  
  avsoas
}


## Obtains the read identifier of the alignment and, when fragments = TRUE, sets
## a different name to each mate.
.getAlnreadids <- function(alnreads, fragments) {
  alnreadids <- character(0)
  alnreadids <- names(alnreads)
  if (fragments) ## with fragments each mate gets here a different read identifier
    alnreadids <- paste(rep(make.names(names(alnreads)), lengths(alnreads)),
                        sequence(lengths(alnreads)), sep=".")
  alnreadids
}


## Find the suboptimal alignment score from the AS of the secondary alignments.
.findSuboptAlignScore <- function(thisalnAS, thissalnmask, alnreadids, salnbestAS) {
  maxsaasbyreadid <- split(thisalnAS[thissalnmask], alnreadids[thissalnmask])
  maxsaasbyreadid <- sapply(maxsaasbyreadid, max)
  mt <- match(names(maxsaasbyreadid), names(salnbestAS))
  if (any(is.na(mt))) {
    tmpas <- rep(NA_integer_, sum(is.na(mt)))
    names(tmpas) <- names(maxsaasbyreadid)[is.na(mt)]
    salnbestAS <- c(salnbestAS, tmpas)
  }
  mt <- match(names(maxsaasbyreadid), names(salnbestAS))
  stopifnot(all(!is.na(mt))) ## QC
  salnbestAS[mt] <- pmax.int(salnbestAS[mt], maxsaasbyreadid, na.rm=TRUE)
  salnbestAS
}



#' @importFrom Matrix rowSums
.adjustcommonTEgene <- function(palnmatfilt, readidx, mask, ov, maskthird, empar, alnreadidx, rd_idx, tx_idx, alnNH) {
  
  ## Identifying multi-mapping reads
  if (length(alnNH) > 0) {
    maskMulti <- alnNH > 2
  } else {
    maskMulti <- duplicated(readidx) | duplicated(readidx, fromLast = TRUE)
    maskMulti <- maskMulti[mask]
  }
  
  maskMultimat <- .buildOvValuesMatrix(ov, maskMulti, alnreadidx, rd_idx, tx_idx)
  maskMultimat <- maskMultimat[maskthird, ]
  maskUniqmat <- .buildOvValuesMatrix(ov, !maskMulti, alnreadidx, rd_idx, tx_idx)
  maskUniqmat <- maskUniqmat[maskthird, ]
  
  istex <- as.vector(empar@features$isTE[tx_idx])
  ## which reads overlap both genes and TEs?
  idx <- (rowSums(palnmatfilt[,istex]) > 0) & (rowSums(palnmatfilt[,!istex]) > 0)
  ## of these, keep only the overlap with the TE in case of a multimapping read
  palnmatfilt[idx,istex] <- as(maskMultimat[idx,istex]*palnmatfilt[idx,istex], "lgCMatrix")
  ## of these, keep only the overlap with the gene in case of a unique read
  palnmatfilt[idx,!istex] <- as(maskUniqmat[idx,!istex]*palnmatfilt[idx,!istex], "lgCMatrix")
  # sum((rowSums(palnmatfilt[,istex]) > 0) & (rowSums(palnmatfilt[,!istex]) > 0)) # [1] 0 (QC) 
  
  ## when multi-mapping / unique reads cannot be identified because there is
  ## no NH and no secondary alignments in the BAM file, 'maskMulti' is FALSE
  ## for all reads, which causes all reads aligned to overlapping genes and TEs 
  ## to be assigned to genes.
  
  palnmatfilt
}


#' @importFrom S4Vectors queryHits subjectHits
#' @importFrom Matrix rowSums
#' @importFrom sparseMatrixStats rowMaxs
.countbymatrix <- function(empar, ov, alnreadidx, salnmask, alnAS, salnbestAS, avgene, applysoasfilter, readidx, mask, alnNH) {
  
  ## fetch all different read identifiers from the overlapping alignments
  rd_idx <- sort(unique(alnreadidx[queryHits(ov)]))
  ## fetch all different transcripts from the overlapping alignments
  tx_idx <- sort(unique(subjectHits(ov)))
  ## build matrix with overlaps of primary alignments
  palnmat <- .buildOvValuesMatrix(ov, !salnmask, alnreadidx, rd_idx, tx_idx)
  
  maskthird <- rep(TRUE, nrow(palnmat))
  
  if (isTRUE(applysoasfilter)) {
    ## build matrices with alignment scores (AS) and best secondary alignment AS
    asmat <- .buildOvValuesMatrix(ov, alnAS, alnreadidx, rd_idx, tx_idx)
    salnbestasmat <- .buildOvValuesMatrix(ov, salnbestAS, alnreadidx, rd_idx, tx_idx)
    ## AS from primary alignments
    asprimaryaln <- rowMaxs(palnmat * asmat)
    ## fetch maximum AS from secondary alignments
    salnmaxas <- rowMaxs(salnbestasmat)
    salnmaxas[salnmaxas == 0] <- -99
    maskthird <- ((asprimaryaln - salnmaxas) >= empar@suboptimalAlignmentCutoff)
  }
  
  cntvec <- rep(0, length(empar@features))
  
  if (isTRUE(avgene)) {
    palnmatadj <- .adjustcommonTEgene(palnmatfilt = palnmat[maskthird, ], readidx, mask, ov, maskthird, empar, alnreadidx, rd_idx, tx_idx, alnNH)
    cntvec[tx_idx] <- colSums(palnmatadj)
  } else {
    cntvec[tx_idx] <- colSums(palnmat[maskthird, ])
  }
  
  ## counting counts of discarded reads mapping to genes
  if (empar@geneCountMode == "all" && applysoasfilter) {
    cntvecdisc <- rep(0, length(empar@features))
    cntvecdisc[tx_idx] <- colSums(palnmat[!maskthird, ])
    cntvec <- cntvec + cntvecdisc
  }
  
  cntvec
}


.filteralnreads <- function (empar, alnreads, mask, thissalnmask, avsoas, avgene) {
  
  if (empar@fragments) {
    if ((avsoas || is.na(empar@suboptimalAlignmentCutoff)) && !avgene) {
      alnreads <- unlist(alnreads)[mask & !thissalnmask]
    } else {
      alnreads <- unlist(alnreads)[mask]
    }
  } else {
    if ((avsoas || is.na(empar@suboptimalAlignmentCutoff)) && !avgene) {
      alnreads <- alnreads[mask & !thissalnmask]
    } else {
      alnreads <- alnreads[mask]
    }
  }
  
}
